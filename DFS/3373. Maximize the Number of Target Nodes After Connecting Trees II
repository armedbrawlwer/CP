class Solution {
public:
    unordered_map<int,vector<int>> makeGraph(vector<vector<int>> &edges){
        unordered_map<int,vector<int>> g;
        for (auto &e : edges){
            int u = e[0], v = e[1];
            g[u].push_back(v);
            g[v].push_back(u);
        }
        return g;
    }

    void dfs(int u, int p, int parity,
             unordered_map<int,vector<int>>& g, vector<int>& color){
        color[u] = parity;
        for (int v : g[u]){
            if (v == p) continue;
            dfs(v, u, parity ^ 1, g, color);
        }
    }

    vector<int> maxTargetNodes(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {
        int n = (int)edges1.size() + 1;
        int m = (int)edges2.size() + 1;

        auto g1 = makeGraph(edges1);
        auto g2 = makeGraph(edges2);

        vector<int> c1(n), c2(m);
        dfs(0, -1, 0, g1, c1);
        dfs(0, -1, 0, g2, c2);

        int ones1 = accumulate(c1.begin(), c1.end(), 0);
        int zeros1 = n - ones1;
        int ones2 = accumulate(c2.begin(), c2.end(), 0);
        int zeros2 = m - ones2;

        // Best you can ever get from tree2 for ANY i
        int g2_best = max(zeros2, ones2);

        vector<int> ans(n);
        for (int i = 0; i < n; ++i){
            int same_in_g1 = c1[i] ? ones1 : zeros1;  // nodes at even distance from i in tree1
            ans[i] = same_in_g1 + g2_best;           // plus optimal contribution from tree2
        }
        return ans;
    }
};
