class trienode{
public:
bool isend;
long long cost;
trienode *children[26];
trienode(){
    isend = false;
    for(int i=0;i<26;i++)
    children[i]=NULL;
    cost=INT_MAX;
}
};

class trie{
    public:
    trienode* root;
    trie(){
        root = new trienode();
    }
    void insertword(string s,long long num){
        trienode *curr = root;
        for(auto ch:s){
            int ind = ch-'a';
            if(curr->children[ind]==NULL){
                curr->children[ind] = new trienode();
            }

            curr = curr->children[ind];
        }
        curr->cost = min(num,curr->cost);
        return;
    }
};

class Solution {
public:
int n;
trie t;
vector<long long> dp;

    long long solve(string &str,int i){
        if(i==n)return 0LL;
        if(dp[i]!=-1)return dp[i];

        long long curr_cost = 0;
        long long ans = INT_MAX;
        trienode* root = t.root;

        for(int j=i;j<n;j++){
            int ind = str[j]-'a';
            if(root->children[ind]==NULL)break;
            root = root->children[ind];
            if(root->cost!=INT_MAX){
                ans = min(ans,root->cost+solve(str,j+1));
            }
        }
        return dp[i]=ans;
        
    }
    

    int minimumCost(string target, vector<string>& words, vector<int>& costs) {
        n=target.size();
        // trie t;
        for(int i=0;i<words.size();i++){
            t.insertword(words[i],costs[i]);
        }
        dp.resize(n+1,-1); 
        int ans=solve(target,0);
        return ans==INT_MAX?-1:ans;
    }
};
